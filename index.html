<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GhostWire | Nexus v3 (Stable)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body { font-family: 'Outfit', sans-serif; background-color: #000; color: #e4e4e7; overflow: hidden; }
        .mono { font-family: 'Space Mono', monospace; }
        
        .glass { background: rgba(20, 20, 20, 0.95); border: 1px solid rgba(255,255,255,0.1); }
        .msg-enter { animation: slideUp 0.2s ease-out; }
        @keyframes slideUp { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        .video-grid { display: grid; grid-template-columns: 1fr; gap: 0; height: 100%; position: relative; }
        .local-video { position: absolute; bottom: 20px; right: 20px; width: 100px; border-radius: 8px; border: 2px solid #22c55e; z-index: 50; background: #000; }
        .remote-video { width: 100%; height: 100%; object-fit: cover; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- V3 CONFIGURATION ---
        // Reduced to 5 to FORCE collisions during testing. 
        // Once working, increase to 20.
        const MAX_SLOTS = 5; 
        
        // Time to wait as host before jumping (10s)
        const HOST_TIMEOUT_MS = 10000; 
        
        // Time to wait for a handshake before declaring "Zombie" (4s)
        const CONNECT_TIMEOUT_MS = 4000;

        // STUN Configuration (Critical for Mobile Data)
        const PEER_CONFIG = {
            debug: 1,
            config: {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' },
                ]
            }
        };

        const Icon = ({ name, size = 20, className = "" }) => {
            const iconRef = useRef(null);
            useEffect(() => {
                if (window.lucide) window.lucide.createIcons({ root: iconRef.current.parentNode, nameAttr: 'data-lucide', attrs: {class: `lucide lucide-${name} ${className}`, width: size, height: size} });
            }, [name]);
            return <i ref={iconRef} data-lucide={name} className={className}></i>;
        };

        const App = () => {
            const [view, setView] = useState('setup');
            const [status, setStatus] = useState('');
            const [logs, setLogs] = useState([]);
            
            // User Data
            const [myGender, setMyGender] = useState('M');
            const [myAge, setMyAge] = useState(25);
            const [targetGender, setTargetGender] = useState('any');

            // Session Data
            const [messages, setMessages] = useState([]);
            const [callActive, setCallActive] = useState(false);
            const [localStream, setLocalStream] = useState(null);
            const [remoteStream, setRemoteStream] = useState(null);

            // Refs
            const peerRef = useRef(null);
            const connRef = useRef(null);
            const callRef = useRef(null);
            const hostTimerRef = useRef(null);
            const connectTimerRef = useRef(null);
            const isStoppedRef = useRef(false);
            const localVideoRef = useRef(null);
            const remoteVideoRef = useRef(null);
            const ignoreListRef = useRef(new Set()); // Slots that failed recently

            // --- Logging ---
            const log = (msg, type='info') => {
                const txt = `[${new Date().toLocaleTimeString().split(' ')[0]}] ${msg}`;
                console.log(txt);
                setLogs(p => [txt, ...p].slice(0, 20));
            };

            // --- Lifecycle ---
            useEffect(() => {
                if (localVideoRef.current && localStream) localVideoRef.current.srcObject = localStream;
                if (remoteVideoRef.current && remoteStream) remoteVideoRef.current.srcObject = remoteStream;
            }, [localStream, remoteStream, callActive]);

            useEffect(() => {
                return () => shutdown();
            }, []);

            // --- Core Logic ---

            const getPool = () => {
                if (targetGender === 'any') return 'global';
                const g = [myGender, targetGender].sort();
                return `${g[0]}${g[1]}`;
            };

            const shutdown = () => {
                isStoppedRef.current = true;
                if(hostTimerRef.current) clearTimeout(hostTimerRef.current);
                if(connectTimerRef.current) clearTimeout(connectTimerRef.current);
                if(callRef.current) callRef.current.close();
                if(connRef.current) connRef.current.close();
                if(peerRef.current) peerRef.current.destroy();
                if(localStream) localStream.getTracks().forEach(t => t.stop());
                setCallActive(false);
                setLocalStream(null);
                setRemoteStream(null);
                setLogs([]);
            };

            const startSearch = useCallback(() => {
                shutdown();
                isStoppedRef.current = false;
                setView('searching');
                setMessages([]);
                ignoreListRef.current = new Set(); // Reset ignore list on new manual search
                cycle();
            }, [myGender, targetGender]);

            const cycle = () => {
                if (isStoppedRef.current) return;

                const pool = getPool();
                // Pick a slot that isn't in ignore list (unless all are ignored, then reset)
                let slot = Math.floor(Math.random() * MAX_SLOTS) + 1;
                
                // If we've failed on this slot recently, pick another
                if (ignoreListRef.current.has(slot) && ignoreListRef.current.size < MAX_SLOTS) {
                    while (ignoreListRef.current.has(slot)) {
                        slot = Math.floor(Math.random() * MAX_SLOTS) + 1;
                    }
                } else if (ignoreListRef.current.size >= MAX_SLOTS) {
                    ignoreListRef.current.clear(); // Clear cache if full
                }

                const id = `gw-v3-${pool}-${slot}`;
                
                setStatus(`Trying Freq ${slot}...`);
                log(`Attempting Slot ${slot} (${pool})`);

                const peer = new window.Peer(id, PEER_CONFIG);

                peer.on('open', (peerId) => {
                    if (isStoppedRef.current) return;
                    peerRef.current = peer;
                    log(`HOSTING Slot ${slot}`, 'success');
                    setStatus(`Hosting Freq ${slot}. Waiting...`);

                    peer.on('connection', (c) => handleConnection(c, true));
                    peer.on('call', (c) => handleCall(c));

                    // Host Timeout: If no one joins, kill and move
                    hostTimerRef.current = setTimeout(() => {
                        log(`No one joined Slot ${slot}. Moving...`);
                        peer.destroy();
                        cycle();
                    }, HOST_TIMEOUT_MS);
                });

                peer.on('error', (err) => {
                    if (err.type === 'unavailable-id') {
                        // Slot Taken -> Try to Connect
                        log(`Slot ${slot} OCCUPIED. Connecting...`, 'warn');
                        setStatus(`Signal found on Freq ${slot}! Connecting...`);
                        peer.destroy();
                        connectTo(id, slot);
                    } else {
                        log(`Peer Error: ${err.type}`);
                        setTimeout(cycle, 1000);
                    }
                });
            };

            const connectTo = (targetId, slot) => {
                const peer = new window.Peer(null, PEER_CONFIG);
                
                peer.on('open', () => {
                    peerRef.current = peer;
                    const conn = peer.connect(targetId, { reliable: true });
                    
                    // Critical: Zombie Killer Timer
                    // If connection doesn't 'open' in X seconds, assume host is a ghost
                    connectTimerRef.current = setTimeout(() => {
                        if (!conn.open) {
                            log(`Slot ${slot} is ZOMBIE (Timeout). Ignoring.`, 'error');
                            ignoreListRef.current.add(slot); // Don't try this slot again for a bit
                            conn.close();
                            peer.destroy();
                            cycle();
                        }
                    }, CONNECT_TIMEOUT_MS);

                    conn.on('open', () => {
                        clearTimeout(connectTimerRef.current); // Safe!
                        handleConnection(conn, false);
                    });

                    conn.on('error', (err) => {
                         log(`Conn Error: ${err}`);
                    });

                    peer.on('call', (c) => handleCall(c));
                });
                
                peer.on('error', (err) => {
                     log(`Client Error: ${err.type}`);
                     setTimeout(cycle, 1000);
                });
            };

            const handleConnection = (conn, amIHost) => {
                if(hostTimerRef.current) clearTimeout(hostTimerRef.current);
                connRef.current = conn;
                log('Connection Established!');
                setView('connected');
                setStatus('Connected');

                // Send Handshake
                conn.send({ type: 'handshake', data: { age: myAge, gender: myGender } });

                conn.on('data', (d) => {
                    if (d.type === 'handshake') {
                        // Validate
                        const valid = (targetGender === 'any' || d.data.gender === targetGender);
                        if (valid) {
                            addMsg(`Connected with ${d.data.gender} (${d.data.age})`, 'sys');
                        } else {
                            addMsg(`Match Criteria Failed. Disconnecting...`, 'sys');
                            setTimeout(() => {
                                conn.close();
                                startSearch(); // Re-roll
                            }, 2000);
                        }
                    } else if (d.type === 'msg') {
                        addMsg(d.content, 'them');
                    }
                });

                conn.on('close', () => {
                    if (!isStoppedRef.current && view === 'connected') {
                        addMsg('Partner disconnected.', 'sys');
                        setTimeout(startSearch, 2000);
                    }
                });
            };

            // --- Media & Chat ---
            const startCall = async () => {
                try {
                    const s = await navigator.mediaDevices.getUserMedia({video:true, audio:true});
                    setLocalStream(s);
                    setCallActive(true);
                    const call = peerRef.current.call(connRef.current.peer, s);
                    handleCallStream(call);
                } catch(e) { alert("Camera Error: " + e); }
            };

            const handleCall = (call) => {
                if(confirm("Accept Video Call?")) {
                    navigator.mediaDevices.getUserMedia({video:true, audio:true}).then(s => {
                        setLocalStream(s);
                        setCallActive(true);
                        call.answer(s);
                        handleCallStream(call);
                    });
                } else { call.close(); }
            };

            const handleCallStream = (call) => {
                callRef.current = call;
                call.on('stream', s => setRemoteStream(s));
                call.on('close', () => { setCallActive(false); setRemoteStream(null); });
            };

            const sendMsg = (e) => {
                e.preventDefault();
                const txt = e.target.msg.value;
                if(!txt) return;
                addMsg(txt, 'me');
                connRef.current.send({type: 'msg', content: txt});
                e.target.msg.value = '';
            };

            const addMsg = (text, sender) => setMessages(p => [...p, {id: Date.now()+Math.random(), text, sender}]);

            // --- UI ---
            if (view === 'setup') return (
                <div className="min-h-screen bg-zinc-950 flex items-center justify-center p-4">
                    <div className="w-full max-w-md glass p-6 rounded-2xl space-y-6">
                        <div className="text-center">
                            <h1 className="text-2xl font-bold text-white tracking-tighter">GHOSTWIRE <span className="text-green-500">v3</span></h1>
                            <p className="text-zinc-500 text-xs mono">STABLE CONNECTIVITY</p>
                        </div>
                        <div className="bg-zinc-900 p-4 rounded-xl space-y-4 border border-zinc-800">
                            <div className="flex justify-between items-center">
                                <span className="text-xs font-bold text-zinc-400">I AM</span>
                                <div className="flex gap-2">
                                    {['M','F'].map(g => <button key={g} onClick={()=>setMyGender(g)} className={`w-10 h-10 rounded font-bold ${myGender===g?'bg-green-600 text-white':'bg-zinc-800 text-zinc-500'}`}>{g}</button>)}
                                </div>
                            </div>
                            <div className="flex justify-between items-center">
                                <span className="text-xs font-bold text-zinc-400">FINDING</span>
                                <div className="flex gap-2">
                                    {['M','F','any'].map(g => <button key={g} onClick={()=>setTargetGender(g)} className={`h-10 px-3 rounded font-bold text-xs uppercase ${targetGender===g?'bg-green-600/20 text-green-400 border border-green-600':'bg-zinc-800 text-zinc-500'}`}>{g}</button>)}
                                </div>
                            </div>
                        </div>
                        <button onClick={startSearch} className="w-full bg-white text-black font-bold py-4 rounded-xl hover:bg-zinc-200 transition-all">START SEARCH</button>
                    </div>
                </div>
            );

            if (view === 'searching') return (
                <div className="min-h-screen bg-black flex flex-col items-center justify-center p-4 relative">
                    <div className="absolute top-4 right-4 w-64 max-h-48 overflow-y-auto text-[10px] mono text-zinc-600 bg-zinc-900/50 p-2 rounded pointer-events-none">
                        {logs.map((l,i)=><div key={i}>{l}</div>)}
                    </div>
                    <div className="relative mb-8">
                        <div className="absolute inset-0 bg-green-500/20 blur-xl rounded-full animate-pulse"></div>
                        <Icon name="loader-2" size={48} className="text-green-500 animate-spin relative z-10" />
                    </div>
                    <h2 className="text-green-500 mono text-sm animate-pulse">{status}</h2>
                    <button onClick={() => { isStoppedRef.current=true; setView('setup'); }} className="mt-8 text-zinc-500 text-xs underline">CANCEL</button>
                </div>
            );

            return (
                <div className="h-screen flex flex-col bg-black">
                    {callActive && (
                        <div className="absolute inset-0 bg-black z-50">
                            <div className="video-grid">
                                <video ref={remoteVideoRef} autoPlay playsInline className="remote-video" />
                                <video ref={localVideoRef} autoPlay playsInline muted className="local-video" />
                            </div>
                            <button onClick={()=>setCallActive(false)} className="absolute bottom-8 left-1/2 -translate-x-1/2 bg-red-600 p-4 rounded-full shadow-xl"><Icon name="phone-off" color="white" /></button>
                        </div>
                    )}
                    
                    <div className="h-14 border-b border-zinc-800 flex items-center justify-between px-4 bg-zinc-900/90">
                        <div className="flex items-center gap-2">
                            <div className="w-2 h-2 bg-green-500 rounded-full animate-pulse"></div>
                            <span className="font-bold text-sm">Anonymous</span>
                        </div>
                        <div className="flex gap-3">
                            <button onClick={startCall} className="text-zinc-400 hover:text-white"><Icon name="video" /></button>
                            <button onClick={startSearch} className="bg-zinc-800 text-xs font-bold px-3 py-1.5 rounded text-white border border-zinc-700">SKIP</button>
                        </div>
                    </div>

                    <div className="flex-1 overflow-y-auto p-4 space-y-3">
                        {messages.map(m => (
                            <div key={m.id} className={`flex ${m.sender==='me'?'justify-end':m.sender==='sys'?'justify-center':'justify-start'} msg-enter`}>
                                <div className={`max-w-[80%] p-3 rounded-2xl text-sm ${m.sender==='me'?'bg-green-600 text-white rounded-br-sm':m.sender==='sys'?'bg-zinc-900 text-zinc-500 text-xs':'bg-zinc-800 text-zinc-200 rounded-bl-sm'}`}>
                                    {m.text}
                                </div>
                            </div>
                        ))}
                    </div>

                    <form onSubmit={sendMsg} className="p-3 bg-zinc-900 border-t border-zinc-800 flex gap-2">
                        <input name="msg" placeholder="Message..." className="flex-1 bg-black border border-zinc-700 rounded-xl px-4 text-sm focus:outline-none focus:border-green-600 text-white" autoComplete="off" />
                        <button className="p-3 bg-green-600 rounded-xl text-black hover:bg-green-500"><Icon name="send" size={18}/></button>
                    </form>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>


